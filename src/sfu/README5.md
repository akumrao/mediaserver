To generate CMakeList.txt

gyp -f cmake  --ignore-environment "--toplevel-dir=." -I/data/mozilla/mediaserver/src/sfu/common.gypi "--depth=." "-Goutput_dir=/data/mozilla/mediaserver/src/sfu/out" "--generator-output=/data/mozilla/mediaserver/src/sfu/out" -Rsfuserver "-Dgcc_version=42" "-Dclang=1" "-Dhost_arch=x64" "-Dtarget_arch=x64" "-Dopenssl_fips=" "-Dsfuserver_asan=false" "-Dnode_byteorder=little" sfuserver.gyp



ICE Gathering

Putting everything together. A client will generally require a TURN server (which has STUN protocol capabilities). Clients then generate a connection offer, and start to generate multiple candidates to be used to stream media to another client. The remote client will exchange the media offer/answers and candidates and then decide how to send media.

Step 1: Allocation

During the WebRTC offer/answer process, a client gathers candidates to be used for ICE. Each candidate is a potential address/port to receive media. Generally, three types of candidates get generated in this initial process.

Host Candidate: Host candidates are generated by the client by binding to its locally assigned IP addresses and port. If you have multiple IP addresses, you can generate multiple host candidates.
Server Reflex Candidate: Server reflex candidates are generated by sending STUN messages to a STUN/TURN server. A client sends a query message to the STUN server. That query passes through the NAT which creates a binding. The response to the query contains the public IP and port that was generated for the binding. This can now be used as a server reflex candidate.
Relay Candidate: Relay candidates are generated in the same way as a server reflex candidate. A query message is sent to the TURN server which creates a NAT binding. That binding is used, but the binding will be sent to and from the relay server.
After a handful of ICE candidates are generated, they must be properly formatted and encoded to be sent to the end client. This encoding can be placed in the offer and answer SDP or be sent standalone (trickle ICE).

Step 2: Exchange

As an offer is generated and sent to the end client. The client can also choose to generate their own candidates and send them, too. The candidates can be packed in the original offer, or can be sent independently after the offer is sent. The latter is known as trickle ICE. The far end client which is now receiving the offer and its accompanying candidates will now begin to prepare its answer. The answer is generated in a similar manner to the way the offer is generated, and an answer SDP is created. The far end client can choose to pack its generated candidates into the SDP or send them independently (again, trickle ICE).

Step 3: Verification

As the offer and answer exchanges take place, each client has an ICE agent handling connection management. After sending and receiving all the candidates, a verification process begins.

Each agent matches up its candidates (local) with its peers (remote) creating candidate pairs.
The agent then sends connectivity checks every 20 ms, in pair priority, over the binding requests from the local candidate to the remote candidate.
Upon receipt of the request, the peer agent generates a response.
If the response is received, the check has succeeded
As agents perform connectivity checks, they may produce additional candidates known as peer reflexive candidates. This usually happens when there is a symmetric NAT in between clients. During the connectivity check process, a STUN request is sent directly to the client, which can generate a brand new binding. If it does, the STUN response is sent back informing the originating client that a new binding was formed. This allows clients to have a direct media path between them, even in the presence of a symmetric NAT.

Step 4: Coordination

At this point, ICE agents should have an idea of which candidate pairs are successfully working. Now, the ICE agent needs to decide which candidate pair it will use for each component in the media stream. One agent acts as a controlling agent, while the other is a passive agent. The controlling agent is typically the offerer. The controlling agent will decide when STUN checks are finished, and which candidate pair to use when verification has finished.

Step 5: Great Success!

Now that a candidate pair is selected, media should be sent to and from the clients. Based on the type of connection, media can flow between clients in a variety of ways.

Host: These clients are on the same LAN and maybe under the same NAT. They can send media direct from host to host.
Server Reflex: STUN has successfully figured out how to create a connection (like punching a hole) through the NATs, and media is flowing between the two clients.
Relay: TURN has successfully allowed media to be sent to an intermediate server between the two NATs. This allows NATs not have to attempt to send traffic between each other if it is not permitted.
Peer Reflex: During connectivity checks we found a better way to send media directly, between clients. One or both clients could be behind symmetric NATs where port preservation is not allowed. In this case, a STUN message allowed a new binding to be created directly between the clients, and in spite of the symmetric NAT. Now, media can flow directly between them.
And that, ladies and gentlemen, is how the magic happens. ICE does a fantastic job of attempting to traverse through multiple NATs.




**SRTP**
The thumbprint (or fingerprint) is just a hash over the certificate to make it easier for humans to compare certificates. It is not included but computed when needed.

A certificate's fingerprint is the unique identifier of the certificate. The Certificate Fingerprint is a digest (hash function) of a certificate in x509 binary format. It can be calculated by different algorithms, such as SHA1 for Microsoft Internet Explorer, and MD5 for Netscape Navigator.



In order to negotiate the security parameters for the media traffic session, SRTP needs to interact with a key management protocol. This protocol is not established, offering up a number of possible options for the task. Two such options are SDES and DTLS-SRTP
SDES over signal   plain

DTLS-SRTP 

Cetificate exchange over DTL+UDP plain
(  use for sctp)


he certificate that is used to encode/decode the SRTP stream is negotiated through DTLS. You need to get the master key from the DTLS negotiation. You cannot do that through packet sniffing. You will have to use the native API and use your own certificate to decode the stream.

You will have to do something similar to the WebRTC Breaker to get the raw rtp stream. 


The spec is assuming that the certificate fingerprints are being exchanged in signaling as they are with DTLS. In DTLS, the fingerprint in the "a=fingerprint" line in SDP is compared with the calculated fingerprint of the certificate exchanged in the DTLS handshake. As a result, in ORTC the ICE and DTLS handshakes can complete, and the Offerer may receive data or media prior to arrival of the Answer that enables the Answerer's fingerprint to be verified.

Since this specification doesn't deal with media over QUIC, we probably don't need to talk about "loss of media". However, I'm wondering if it's possible for QUIC data to be received prior to fingerprint verification. If so, this probably shouldn't be passed to the application prior to verification.